<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Ocean Shipping and Urban Deliveries: DataManip Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Ocean Shipping and Urban Deliveries
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classDataManip-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">DataManip Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a429abd4d3690c231858d63f6e126a8f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a429abd4d3690c231858d63f6e126a8f9">DataManip</a> ()</td></tr>
<tr class="memdesc:a429abd4d3690c231858d63f6e126a8f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor for <a class="el" href="classDataManip.html">DataManip</a> class.  <a href="classDataManip.html#a429abd4d3690c231858d63f6e126a8f9">More...</a><br /></td></tr>
<tr class="separator:a429abd4d3690c231858d63f6e126a8f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166acbbbc712671472ee00bfc65e9990"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a166acbbbc712671472ee00bfc65e9990">clearData</a> ()</td></tr>
<tr class="memdesc:a166acbbbc712671472ee00bfc65e9990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the current data, resetting the best path, best cost, and graph.  <a href="classDataManip.html#a166acbbbc712671472ee00bfc65e9990">More...</a><br /></td></tr>
<tr class="separator:a166acbbbc712671472ee00bfc65e9990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9e9d3d4947cadb19373f7a3a7b9904"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#afe9e9d3d4947cadb19373f7a3a7b9904">getBestPath</a> () const</td></tr>
<tr class="memdesc:afe9e9d3d4947cadb19373f7a3a7b9904"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the best path computed by the algorithm.  <a href="classDataManip.html#afe9e9d3d4947cadb19373f7a3a7b9904">More...</a><br /></td></tr>
<tr class="separator:afe9e9d3d4947cadb19373f7a3a7b9904"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cdbb321aca683e55d584a8e6c248b80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a0cdbb321aca683e55d584a8e6c248b80">getBestCost</a> () const</td></tr>
<tr class="memdesc:a0cdbb321aca683e55d584a8e6c248b80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the best cost computed by the algorithm.  <a href="classDataManip.html#a0cdbb321aca683e55d584a8e6c248b80">More...</a><br /></td></tr>
<tr class="separator:a0cdbb321aca683e55d584a8e6c248b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad202b803cfdfc7e6c065d21126849d4e"><td class="memItemLeft" align="right" valign="top"><a id="ad202b803cfdfc7e6c065d21126849d4e" name="ad202b803cfdfc7e6c065d21126849d4e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>readTourism</b> (string filename)</td></tr>
<tr class="memdesc:ad202b803cfdfc7e6c065d21126849d4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads tourism data from a file and populates the graph. <br /></td></tr>
<tr class="separator:ad202b803cfdfc7e6c065d21126849d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d2c9b11852cac444c152a40498e17c"><td class="memItemLeft" align="right" valign="top"><a id="a10d2c9b11852cac444c152a40498e17c" name="a10d2c9b11852cac444c152a40498e17c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>readEdges</b> (string filename)</td></tr>
<tr class="memdesc:a10d2c9b11852cac444c152a40498e17c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads edges from a file and populates the graph. <br /></td></tr>
<tr class="separator:a10d2c9b11852cac444c152a40498e17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8c146d1e32395d7f70867eed25491be"><td class="memItemLeft" align="right" valign="top"><a id="aa8c146d1e32395d7f70867eed25491be" name="aa8c146d1e32395d7f70867eed25491be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>readNodes</b> (string filename)</td></tr>
<tr class="memdesc:aa8c146d1e32395d7f70867eed25491be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads node information from a file and adds them to the graph. <br /></td></tr>
<tr class="separator:aa8c146d1e32395d7f70867eed25491be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4020e500e803aaa69e2980db7e0787f4"><td class="memItemLeft" align="right" valign="top"><a id="a4020e500e803aaa69e2980db7e0787f4" name="a4020e500e803aaa69e2980db7e0787f4"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>readToy</b> (string filename)</td></tr>
<tr class="memdesc:a4020e500e803aaa69e2980db7e0787f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads toy dataset from a file and populates the graph. <br /></td></tr>
<tr class="separator:a4020e500e803aaa69e2980db7e0787f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bda8c70d52e29a860ea2b584f51489c"><td class="memItemLeft" align="right" valign="top"><a id="a7bda8c70d52e29a860ea2b584f51489c" name="a7bda8c70d52e29a860ea2b584f51489c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>readEdgesLarge</b> (string filename)</td></tr>
<tr class="memdesc:a7bda8c70d52e29a860ea2b584f51489c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads large edges data from a file and populates the graph. <br /></td></tr>
<tr class="separator:a7bda8c70d52e29a860ea2b584f51489c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5508f5547264bae9aacb022a2bd1acec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a5508f5547264bae9aacb022a2bd1acec">RecursiveBackTracking</a> (vector&lt; int &gt; &amp;path, double currCost, int currPos)</td></tr>
<tr class="memdesc:a5508f5547264bae9aacb022a2bd1acec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs recursive backtracking to find the best path.  <a href="classDataManip.html#a5508f5547264bae9aacb022a2bd1acec">More...</a><br /></td></tr>
<tr class="separator:a5508f5547264bae9aacb022a2bd1acec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf73662bc5efa11ae0a2ab1b6438b77"><td class="memItemLeft" align="right" valign="top"><a id="abbf73662bc5efa11ae0a2ab1b6438b77" name="abbf73662bc5efa11ae0a2ab1b6438b77"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>Solution</b> (const std::vector&lt; int &gt; &amp;path)</td></tr>
<tr class="separator:abbf73662bc5efa11ae0a2ab1b6438b77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a701636323a67a68cfe24c81d320593b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a701636323a67a68cfe24c81d320593b7">Bound</a> (double currCost)</td></tr>
<tr class="memdesc:a701636323a67a68cfe24c81d320593b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the current cost is less than the best cost.  <a href="classDataManip.html#a701636323a67a68cfe24c81d320593b7">More...</a><br /></td></tr>
<tr class="separator:a701636323a67a68cfe24c81d320593b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8728c7e89095432ff85c145b7f374b00"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a8728c7e89095432ff85c145b7f374b00">TriangularApprox</a> (vector&lt; int &gt; &amp;path)</td></tr>
<tr class="memdesc:a8728c7e89095432ff85c145b7f374b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Triangular Approximation Algorithm to find an approximate solution for the TSP.  <a href="classDataManip.html#a8728c7e89095432ff85c145b7f374b00">More...</a><br /></td></tr>
<tr class="separator:a8728c7e89095432ff85c145b7f374b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ccb85905c61e945021a78c4cc2e2e22"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a2ccb85905c61e945021a78c4cc2e2e22">CalculateTourCost</a> (vector&lt; int &gt; &amp;path)</td></tr>
<tr class="memdesc:a2ccb85905c61e945021a78c4cc2e2e22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the cost of a tour represented by a sequence of vertices.  <a href="classDataManip.html#a2ccb85905c61e945021a78c4cc2e2e22">More...</a><br /></td></tr>
<tr class="separator:a2ccb85905c61e945021a78c4cc2e2e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade781c1a0408ab0e2c453587e7fd9d88"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#ade781c1a0408ab0e2c453587e7fd9d88">NearestNeighborApprox</a> (vector&lt; int &gt; &amp;path)</td></tr>
<tr class="memdesc:ade781c1a0408ab0e2c453587e7fd9d88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Nearest Neighbor Approximation Algorithm to find an approximate solution for the TSP.  <a href="classDataManip.html#ade781c1a0408ab0e2c453587e7fd9d88">More...</a><br /></td></tr>
<tr class="separator:ade781c1a0408ab0e2c453587e7fd9d88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa97e5da4f96a260a724a42b3e9d7c54e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#aa97e5da4f96a260a724a42b3e9d7c54e">simulatedAnnealing</a> (vector&lt; int &gt; &amp;path, double initialTemperature=5000.0, double coolingRate=0.95)</td></tr>
<tr class="memdesc:aa97e5da4f96a260a724a42b3e9d7c54e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Simulated Annealing algorithm to find an approximate solution for the TSP.  <a href="classDataManip.html#aa97e5da4f96a260a724a42b3e9d7c54e">More...</a><br /></td></tr>
<tr class="separator:aa97e5da4f96a260a724a42b3e9d7c54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e76db2836027be8f41b644d8ba25fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a54e76db2836027be8f41b644d8ba25fc">resetGraph</a> (std::unordered_set&lt; int &gt; &amp;unvisitedNodes)</td></tr>
<tr class="memdesc:a54e76db2836027be8f41b644d8ba25fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the visited status of vertices in the graph and populates the set of unvisited nodes.  <a href="classDataManip.html#a54e76db2836027be8f41b644d8ba25fc">More...</a><br /></td></tr>
<tr class="separator:a54e76db2836027be8f41b644d8ba25fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016565b62353d15acdb62bcd31aa0f80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a016565b62353d15acdb62bcd31aa0f80">findNearestNeighbor</a> (int currentNode, double &amp;minDistance)</td></tr>
<tr class="memdesc:a016565b62353d15acdb62bcd31aa0f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the nearest unvisited neighbor of a given vertex.  <a href="classDataManip.html#a016565b62353d15acdb62bcd31aa0f80">More...</a><br /></td></tr>
<tr class="separator:a016565b62353d15acdb62bcd31aa0f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8606ee877a646a882c164f8e1a08f72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#af8606ee877a646a882c164f8e1a08f72">findNearestNeighborNotConnected</a> (int currentNode, double &amp;minDistance)</td></tr>
<tr class="memdesc:af8606ee877a646a882c164f8e1a08f72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the nearest unvisited neighbor directly connected to a given vertex.  <a href="classDataManip.html#af8606ee877a646a882c164f8e1a08f72">More...</a><br /></td></tr>
<tr class="separator:af8606ee877a646a882c164f8e1a08f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7360ebd23d5e5dcc27818856ae84bdc3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a7360ebd23d5e5dcc27818856ae84bdc3">NearestNeighborApproxNotConnected</a> (std::vector&lt; int &gt; &amp;route, int startNode)</td></tr>
<tr class="memdesc:a7360ebd23d5e5dcc27818856ae84bdc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the Nearest Neighbor Approximation Algorithm for a graph with disconnected components.  <a href="classDataManip.html#a7360ebd23d5e5dcc27818856ae84bdc3">More...</a><br /></td></tr>
<tr class="separator:a7360ebd23d5e5dcc27818856ae84bdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07820ea9a44d26b482cae7d99d05116a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGraph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataManip.html#a07820ea9a44d26b482cae7d99d05116a">getGraph</a> ()</td></tr>
<tr class="memdesc:a07820ea9a44d26b482cae7d99d05116a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the graph associated with the <a class="el" href="classDataManip.html">DataManip</a> object.  <a href="classDataManip.html#a07820ea9a44d26b482cae7d99d05116a">More...</a><br /></td></tr>
<tr class="separator:a07820ea9a44d26b482cae7d99d05116a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a429abd4d3690c231858d63f6e126a8f9" name="a429abd4d3690c231858d63f6e126a8f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429abd4d3690c231858d63f6e126a8f9">&#9670;&nbsp;</a></span>DataManip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DataManip::DataManip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor for <a class="el" href="classDataManip.html">DataManip</a> class. </p>
<p >This constructor initializes a <a class="el" href="classDataManip.html">DataManip</a> object. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a701636323a67a68cfe24c81d320593b7" name="a701636323a67a68cfe24c81d320593b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a701636323a67a68cfe24c81d320593b7">&#9670;&nbsp;</a></span>Bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool DataManip::Bound </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>currCost</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the current cost is less than the best cost. </p>
<p >This method checks if the current cost is less than the best cost obtained so far. If the current cost is less than the best cost, it indicates that the current path being explored is promising and can potentially lead to a better solution.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currCost</td><td>The current cost to be compared with the best cost.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool True if the current cost is less than the best cost, indicating a promising path. False otherwise. </dd></dl>

</div>
</div>
<a id="a2ccb85905c61e945021a78c4cc2e2e22" name="a2ccb85905c61e945021a78c4cc2e2e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ccb85905c61e945021a78c4cc2e2e22">&#9670;&nbsp;</a></span>CalculateTourCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DataManip::CalculateTourCost </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates the cost of a tour represented by a sequence of vertices. </p>
<p >This method calculates the total cost of a tour represented by a sequence of vertices. It computes the sum of distances between consecutive vertices in the tour. If the distance between two vertices is not directly available in the graph, it calculates the distance using the Haversine formula based on their latitude and longitude.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A vector representing the sequence of vertices in the tour.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The total cost of the tour.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this method depends on the size and structure of the graph, as it involves traversing the vertices in the given path and calculating distances between them. If the distance between two vertices is not directly available in the graph, calculating the distance using the Haversine formula contributes to the overall time complexity. </dd></dl>

</div>
</div>
<a id="a166acbbbc712671472ee00bfc65e9990" name="a166acbbbc712671472ee00bfc65e9990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166acbbbc712671472ee00bfc65e9990">&#9670;&nbsp;</a></span>clearData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::clearData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the current data, resetting the best path, best cost, and graph. </p>
<dl class="section note"><dt>Note</dt><dd>Time Complexity: O(1) </dd></dl>

</div>
</div>
<a id="a016565b62353d15acdb62bcd31aa0f80" name="a016565b62353d15acdb62bcd31aa0f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a016565b62353d15acdb62bcd31aa0f80">&#9670;&nbsp;</a></span>findNearestNeighbor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DataManip::findNearestNeighbor </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>minDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the nearest unvisited neighbor of a given vertex. </p>
<p >This method finds the nearest unvisited neighbor of a given vertex in the graph. It first checks for directly connected neighbors and then searches for the nearest unvisited node in the entire graph if no directly connected neighbor is found or if the minimum distance is greater than 9000.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentNode</td><td>The ID of the current node for which the nearest neighbor is to be found. </td></tr>
    <tr><td class="paramname">minDistance</td><td>Reference to a double variable to store the minimum distance to the nearest neighbor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The ID of the nearest unvisited neighbor vertex.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this method depends on the size and structure of the graph. In the worst case, if no directly connected neighbor is found, it iterates over all vertices in the graph to find the nearest unvisited node, resulting in O(V) complexity, where V is the number of vertices in the graph. </dd></dl>

</div>
</div>
<a id="af8606ee877a646a882c164f8e1a08f72" name="af8606ee877a646a882c164f8e1a08f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8606ee877a646a882c164f8e1a08f72">&#9670;&nbsp;</a></span>findNearestNeighborNotConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DataManip::findNearestNeighborNotConnected </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currentNode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>minDistance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the nearest unvisited neighbor directly connected to a given vertex. </p>
<p >This method finds the nearest unvisited neighbor directly connected to a given vertex in the graph. If no directly connected neighbor is found, it returns -1, indicating that no such neighbor exists.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">currentNode</td><td>The ID of the current node for which the nearest neighbor is to be found. </td></tr>
    <tr><td class="paramname">minDistance</td><td>Reference to a double variable to store the minimum distance to the nearest neighbor.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int The ID of the nearest unvisited neighbor vertex directly connected to the current node, or -1 if no such neighbor exists.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this method depends on the size and structure of the graph. It iterates over the adjacent vertices of the current node to find the nearest unvisited neighbor, resulting in O(E) complexity, where E is the number of edges incident to the current node. </dd></dl>

</div>
</div>
<a id="a0cdbb321aca683e55d584a8e6c248b80" name="a0cdbb321aca683e55d584a8e6c248b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cdbb321aca683e55d584a8e6c248b80">&#9670;&nbsp;</a></span>getBestCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int DataManip::getBestCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the best cost computed by the algorithm. </p>
<p >This method returns the best cost as an integer. The best cost is assumed to be computed and stored in the class instance.</p>
<dl class="section return"><dt>Returns</dt><dd>int The best cost computed by the algorithm.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this method is O(1), as it simply returns the stored integer. </dd></dl>

</div>
</div>
<a id="afe9e9d3d4947cadb19373f7a3a7b9904" name="afe9e9d3d4947cadb19373f7a3a7b9904"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9e9d3d4947cadb19373f7a3a7b9904">&#9670;&nbsp;</a></span>getBestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; DataManip::getBestPath </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the best path computed by the algorithm. </p>
<p >This method returns the best path as a vector of integers. The best path is assumed to be computed and stored in the class instance.</p>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;int&gt; The best path as a vector of integers.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this method is O(1), as it simply returns the stored vector. </dd></dl>

</div>
</div>
<a id="a07820ea9a44d26b482cae7d99d05116a" name="a07820ea9a44d26b482cae7d99d05116a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07820ea9a44d26b482cae7d99d05116a">&#9670;&nbsp;</a></span>getGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGraph.html">Graph</a> DataManip::getGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieves the graph associated with the <a class="el" href="classDataManip.html">DataManip</a> object. </p>
<p >This method returns a copy of the graph stored within the <a class="el" href="classDataManip.html">DataManip</a> object. The graph represents the underlying structure on which various graph algorithms are performed within the <a class="el" href="classDataManip.html">DataManip</a> class.</p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classGraph.html">Graph</a> The graph associated with the <a class="el" href="classDataManip.html">DataManip</a> object. </dd></dl>

</div>
</div>
<a id="ade781c1a0408ab0e2c453587e7fd9d88" name="ade781c1a0408ab0e2c453587e7fd9d88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade781c1a0408ab0e2c453587e7fd9d88">&#9670;&nbsp;</a></span>NearestNeighborApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DataManip::NearestNeighborApprox </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the Nearest Neighbor Approximation Algorithm to find an approximate solution for the TSP. </p>
<p >This method implements the Nearest Neighbor Approximation Algorithm to find an approximate solution for the Traveling Salesman Problem (TSP). It starts from an initial vertex (usually vertex 0) and iteratively selects the nearest unvisited neighbor until all vertices are visited. It returns to the start vertex to complete the tour. The approximate tour and its total cost are stored in the provided route vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">route</td><td>Reference to a vector to store the approximate tour found by the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The total cost of the approximate tour.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this method depends on the size and structure of the graph. In the worst case, it iterates over all vertices in the graph and their adjacent vertices, resulting in O(V^2) complexity, where V is the number of vertices in the graph. </dd></dl>

</div>
</div>
<a id="a7360ebd23d5e5dcc27818856ae84bdc3" name="a7360ebd23d5e5dcc27818856ae84bdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7360ebd23d5e5dcc27818856ae84bdc3">&#9670;&nbsp;</a></span>NearestNeighborApproxNotConnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DataManip::NearestNeighborApproxNotConnected </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>route</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>startNode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the Nearest Neighbor Approximation Algorithm for a graph with disconnected components. </p>
<p >This method implements the Nearest Neighbor Approximation Algorithm to find an approximate solution for the Traveling Salesman Problem (TSP) on a graph with disconnected components. It starts from a specified start node and iteratively selects the nearest unvisited neighbor until all vertices are visited. It returns to the start node to complete the tour. The approximate tour and its total cost are stored in the provided route vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">route</td><td>Reference to a vector to store the approximate tour found by the algorithm. </td></tr>
    <tr><td class="paramname">startNode</td><td>The ID of the start node from which the algorithm begins the tour.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The total cost of the approximate tour.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This method assumes that the graph may have disconnected components. It iterates over all unvisited nodes to find the nearest neighbor, resulting in O(V^2) complexity in the worst case, where V is the number of vertices in the graph. </dd></dl>

</div>
</div>
<a id="a5508f5547264bae9aacb022a2bd1acec" name="a5508f5547264bae9aacb022a2bd1acec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5508f5547264bae9aacb022a2bd1acec">&#9670;&nbsp;</a></span>RecursiveBackTracking()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::RecursiveBackTracking </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>currCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>currPos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs recursive backtracking to find the best path. </p>
<p >This method performs recursive backtracking to explore all possible paths in the graph starting from the current position. It updates the best path and cost if a better solution is found during the exploration process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>A vector representing the current path being explored. </td></tr>
    <tr><td class="paramname">currCost</td><td>The current cost of the path being explored. </td></tr>
    <tr><td class="paramname">currPos</td><td>The current position (vertex) in the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a54e76db2836027be8f41b644d8ba25fc" name="a54e76db2836027be8f41b644d8ba25fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e76db2836027be8f41b644d8ba25fc">&#9670;&nbsp;</a></span>resetGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DataManip::resetGraph </td>
          <td>(</td>
          <td class="paramtype">std::unordered_set&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>unvisitedNodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets the visited status of vertices in the graph and populates the set of unvisited nodes. </p>
<p >This method resets the visited status of all vertices in the graph to false and populates the set of unvisited nodes with the IDs of all vertices in the graph.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unvisitedNodes</td><td>Reference to an unordered set to store the IDs of unvisited nodes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this method is O(V), where V is the number of vertices in the graph, as it iterates over all vertices in the graph and performs constant-time operations to reset their visited status and insert their IDs into the set of unvisited nodes. </dd></dl>

</div>
</div>
<a id="aa97e5da4f96a260a724a42b3e9d7c54e" name="aa97e5da4f96a260a724a42b3e9d7c54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa97e5da4f96a260a724a42b3e9d7c54e">&#9670;&nbsp;</a></span>simulatedAnnealing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DataManip::simulatedAnnealing </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>initialTemperature</em> = <code>5000.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>coolingRate</em> = <code>0.95</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the Simulated Annealing algorithm to find an approximate solution for the TSP. </p>
<p >This method implements the Simulated Annealing algorithm to find an approximate solution for the Traveling Salesman Problem (TSP). It starts from an initial solution and iteratively explores neighboring solutions, accepting worse solutions with a certain probability based on the current temperature and the difference in cost between the current and neighbor solutions. The algorithm gradually decreases the temperature over iterations according to a cooling rate until a termination condition is met. The approximate tour and its total cost are stored in the provided path vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Reference to a vector to store the approximate tour found by the algorithm. </td></tr>
    <tr><td class="paramname">initialTemperature</td><td>The initial temperature parameter for the simulated annealing process. </td></tr>
    <tr><td class="paramname">coolingRate</td><td>The cooling rate parameter for the simulated annealing process.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The total cost of the approximate tour.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this method depends on the number of iterations and the complexity of the neighbor solution generation process. Typically, the algorithm performs a large number of iterations, resulting in a high time complexity. The overall time complexity is often non-deterministic due to the probabilistic nature of the acceptance of worse solutions. </dd></dl>

</div>
</div>
<a id="a8728c7e89095432ff85c145b7f374b00" name="a8728c7e89095432ff85c145b7f374b00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8728c7e89095432ff85c145b7f374b00">&#9670;&nbsp;</a></span>TriangularApprox()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double DataManip::TriangularApprox </td>
          <td>(</td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the Triangular Approximation Algorithm to find an approximate solution for the TSP. </p>
<p >This method implements the Triangular Approximation Algorithm to find an approximate solution for the Traveling Salesman Problem (TSP). It consists of the following steps:</p><ol type="1">
<li>Executes Prim's algorithm to calculate the Minimum Spanning Tree (MST) of the graph.</li>
<li>Performs a pre-order traversal of the MST to obtain a minimum path.</li>
<li>Constructs a tour from the minimum path by visiting each vertex once.</li>
<li>Calculates the cost of the tour.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">path</td><td>Reference to a vector to store the approximate tour found by the algorithm.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>double The cost of the approximate tour.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The time complexity of this method depends on the size and structure of the graph, as it involves executing Prim's algorithm, performing a pre-order traversal, constructing a tour, and calculating its cost. The overall complexity is typically dominated by the time complexity of Prim's algorithm and the pre-order traversal, which are both O(V^2) for dense graphs and O(V + E) for sparse graphs, where V is the number of vertices and E is the number of edges in the graph. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/edu/Feup/2ยบ ano/2ยบ semestre/DA/Projetos/DA_project2/src/<a class="el" href="DataManip_8h_source.html">DataManip.h</a></li>
<li>/home/edu/Feup/2ยบ ano/2ยบ semestre/DA/Projetos/DA_project2/src/DataManip.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
